# 02. 단위 테스트란 무엇인가

## 1. 단위 테스트의 정의

단위 테스트는

- 작은 코드 조각 (단위)을 검증하고,
- 빠르게 수행하고,
- 격리된 방식으로 처리하는 자동화된 테스트를 말한다.

격리가 정확히 무엇인지에 대한 의견 차이로 단위 테스트의 고전파와 런던파가 나뉘게 된다.

### 1-1. 격리 문제에 대한 런던파의 접근 (Mockist)

- 코드 조각 (단위)을 격리된 방식으로 검증한다는 것은, 테스트 대상 시스템을 협력자 (collaborator)에게서 격리하는 것을 일컫는다.
- 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면, 이 모든 의존성을 테스트 대역 (test double)으로 대체한다.
  - 동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중할 수 있다.

#### 장점

- 테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알 수 있다. 
- 객체 그래프 (object graph: 같은 문제를 해결하는 클래스의 통신망)를 분할할 수 있다.

### 1-2. 격리 문제에 대한 고전파의 접근 (Detroit)

- 코드를 꼭 격리하는 방식으로 테스트해야하는 것은 아니다.
  - 대신, 단위 테스트는 서로 격리해서 실행해야 한다. 이렇게 하면 테스트를 어떤 순서 (병렬 또는 순차)로든 가장 적합한 방식으로 실행할 수 있으며, 서로의 결과에 영향을 미치지 않는다.

### 공유 의존성 (shared dependency)

- 테스트 대상 클래스 간이 아닌, **테스트** 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성
- ex) 정적 가변 필드 (static mutable field), 데이터베이스
- 동일한 프로세스 내에서 실행되는 모든 단위 테스트에서 볼 수 있다.
- 모든 공유 의존성은 변경 가능하지만, 변경 가능한 의존성을 공유하려면 여러 테스트에서 재사용되어야 한다.
- 공유 의존성을 대체하는 또 다른 이유는, 테스트 실행 속도를 높이는 데 있다.
  - 공유 의존성은 거의 항상 실행 프로세스 외부에 있는 반면, 비공개 의존성은 보통 그 경계를 넘지 않기 때문에 공유 의존성에 대한 호출이 비공개 의존성에 대한 호출보다 오래 걸린다.


### 비공개 의존성 (private dependency)

- 공유하지 않는 의존성

### 프로세스 외부 의존성 (out-of-process dependency)

- 애플리케이션 실행 프로세스 외부에서 실행되는 의존성으로, 아직 메모리에 없는 데이터에 대한 프록시 (Proxy) 이다.
- 프로세스 외부 의존성은 대부분 공유 의존성에 해당하지만 모두 그런 것은 아니다.

## 단위 테스트의 런던파와 고전파

2개의 분파는 크게 격리 요구 사항, 테스트 대상 코드 조각 (단위)의 구성 요소, 의존성 처리의 3가지 주요 주제에 대해 의견 차이가 있다.

|            | 격리 주체   | 단위의 크기                  | 테스트 대역 사용 대상      |
| ---------- | ----------- | ---------------------------- | -------------------------- |
| **런던파** | 단위        | 단일 클래스                  | 불변 의존성 외 모든 의존성 |
| **고전파** | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성                |

### 런던파

- 테스트 대상 단위를 서로 분리해야 한다고 한다.
  - 테스트 대상 단위는 코드의 단위, 보통 단일 클래스. 불변 의존성을 제외한 모든 의존성을 테스트 대역으로 대체해야 한다.
- 더 나은 입자성의 이점
  - 테스트가 세밀해서 한 번에 한 클래스만 확인
- 상호 연결된 클래스의 큰 그래프에 대한 테스트 용이성
  - 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체되므로 테스트 작성 시 걱정할 필요가 없다. 
- 테스트 실패 후 버그가 있는 기능을 쉽게 찾을 수 있는 편의성
  - 테스트가 실패하면 어떤 테스트가 실패했는지 확실히 알 수 있다. 클래스의 협력자가 없으면 테스트 대상 클래스 외에 다른 것을 의심할 여지가 없다.
- 단위 테스트는 하향식 TDD로 이어지며, 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작한다. 목을 사용해 예상 결과를 달성하고자 시스템이 통신해야 하는 협력자를 지정하고, 모든 클래스를 구현할 때까지 클래스 그래프를 다져나간다.
- 문제는 과잉 명세, 즉 SUT 세부 구현에 결합된 테스트 문제이다.

### 고전파

- 단위가 아니라 단위 테스트를 서로 분리해야 한다고 한다.
- 또한, 테스트 대상 단위는 코드 단위가 아닌 동작 단위이다. 따라서 공유 의존성만 테스트 대역으로 대체해야 한다. 
  - 공유 의존성은 테스트가 서로 실행 흐름에 영향을 미치는 수단을 제공하는 의존성
- 테스트에서 실제 객체를 다뤄야 하기 때문에 상향식으로 한다. 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둔다.
- 단위 테스트는 단일 동작 단위를 검증하고, 빠르게 수행하고, 단위 테스트와 별도로 처리한다.

### 협력자 대 의존성

- 협력자는 공유하거나 변경 가능한 의존성이다.

<img width="659" alt="스크린샷 2022-07-19 오후 6 32 28" src="https://user-images.githubusercontent.com/95578975/179718259-9f9c422b-1d82-495f-9bfa-af2b7632fb62.png">

- 공유이지만 프로세스 외부가 아닌 의존성 : 싱글톤, 클래스의 정적 필드
- 공유이면서 프로세스 외부 : 데이터베이스
- 프로세스 외부에 있으면서 공유되지 않음 : 읽기 전용 API -> 수정할 수 없고, 이로 인해 서로의 실행 흐름에 영향을 줄 수 없기 때문

### 통합 테스트의 일부인 엔드 투 엔드 테스트

- 통합 테스트는 공유 의존성, 프로세스 외부 의존성 뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트
  - 단위 테스트 기준 중 하나 이상을 충족하지 못하는 테스트
- 엔드 투 엔드 테스트는 통합 테스트의 일부로, 코드가 프로세스 외부 종속성과 함께 어떻게 작동하는지 검증하는 테스트
- 엔드 투 엔드 테스트와 통합 테스트의 차이점은, 엔드 투 엔드 테스트가 일반적으로 의존성을 더 많이 포함한다.
  - 통합 테스트는 프로세스 외부 의존성을 한두개만 갖고 작동
  - 엔드 투 엔드 테스트는 프로세스 외부 의존성을 전부 또는 대다수 갖고 작동하므로, 엔드 투 엔드라는 명칭은 모든 외부 애플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것을 의미한다.
- 엔드 투 엔드 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에, 모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋다.
