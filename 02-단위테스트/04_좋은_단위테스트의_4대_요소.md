# 04. 좋은 단위 테스트의 4대 요소

## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기

### 좋은 단위 테스트의 4가지 특성

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

이 4가지 특성으로 어떤 자동화된 테스트 (단위 테스트, 통합 테스트, 엔드 투 엔드 테스트)도 분석할 수 있다. 

### 1-1. 첫 번째 요소 : 회귀 방지

- 회귀
  - 코드를 수정한 후 (일반적으로 새 기능을 출시한 후) 기능이 의도한 대로 작동하지 않는 경우
- 회귀 방지 지표에 대한 테스트 점수를 평가하려면 다음 사항을 고려해야 한다.
  - 테스트 중에 실행되는 코드의 양 → 일반적으로 실행 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.
  - 코드 복잡도 → 복잡한 비즈니스 로직을 나타내는 코드가 보일러 플레이트 코드보다 훨씬 더 중요하다. 비즈니스에 중요한 기능에서 발생한 버그가 가장 큰 피해를 입히기 때문.
  - 코드의 도메인 유의성
- 단순한 코드를 테스트하는 것은 실수할 여지가 많지 않기 때문에 회귀 오류도 많이 생기지 않고, 가치가 거의 없다. 
- 본인이 작성하지 않은 코드 (ex. 라이브러리, 프레임워크, 프로젝트에서 쓰는 외부 시스템)는 소프트웨어 작동에 영향을 미치므로, 테스트 범주에 포함시켜서 소프트웨어가 이러한 의존성에 대해 검증이 올바른지 확인한다.

⇒ 회귀 방지 지표 극대화를 위해서는 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.

### 1-2. 두 번째 요소 : 리팩터링 내성

- 리팩터링 내성
  - 테스트가 실패로 바뀌지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도
- 리팩터링
  - 식별할 수 있는 동작을 수정하지 않고 기존 코드를 변경하는 것
  - 코드의 비기능적 특징을 개선함으로써 가독성을 높이고 복잡도를 낮춘다.
  - ex. 메서드 이름 변경, 코드 조각을 새로운 클래스로 추출
- 거짓 양성 (false positive)
  - 실제로 기능이 의도한 대로 동작하지만, 테스트는 실패를 나타내는 결과
  - 주로 코드 리팩토링 시, 구현을 수정하지만 식별할 수 있는 동작은 유지할 때 발생한다.
- 테스트가 지속 가능한 성장을 하게 하는 메커니즘은 회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가할 수 있는 것이다.
  - 이점 1. 기존 기능이 고장났을 때 테스트가 조기 경고를 제공하기 때문에, 배포 전에 문제 해결 가능
  - 이점 2. 코드 변경이 회귀로 이어지지 않을 것이라고 확신. 확신이 없다면 리팩터링을 주저하게 되고 코드베이스가 나빠질 가능성이 훨씬 높아진다.
- 거짓 양성은 위의 두 이점을 모두 방해한다.
  - 테스트가 타당한 이유 없이 실패하면 코드 문제에 대응하는 능력과 의지가 희석된다. 
  - 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 떨어지고, 허위 경보로 인식이 나빠진다. 신뢰가 부족해져서 리팩터링도 줄어들게 된다. 

### 1-3. 무엇이 거짓 양성의 원인인가?

- 테스트에서 발생하는 거짓 양성의 수는 테스트 구성 방식과 직접적인 관련이 있다. 
  - 테스트와 테스트 대상 시스템 (SUT)의 구현 세부 사항이 많이 결합할수록 허위 경보가 더 많이 생긴다.
  - 거짓 양성이 생길 가능성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리하는 것이다. 
- 테스트는 최종 사용자의 관점에서 SUT를 검증해야하고 최종 사용자에게 의미 있는 결과만 확인해야 한다.
- **리팩터링 과정**이란, 애플리케이션의 식별할 수 있는 동작에 영향을 주지 않으면서 구현을 변경하는 것
  - 변경할 때마다 테스트가 실패하는 것은, 테스트가 구현 세부사항에 관계되어있기 때문
- SUT의 구현 세부 사항과 결합된 테스트는 리팩터링 내성이 없다. 

### 1-4. 구현 세부 사항 대신 최종 결과를 목표로 하기

- 테스트를 깨지지 않게 하고 리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는 것이다.
  - 즉, 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 하는 것

## 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

프로젝트 시작 직후에는 회귀 방지를 훌륭히 갖추는 것이 중요한 데 반해, 리팩터링 내성은 바로 필요하지 않다.

### 2-1. 테스트 정확도 극대화

다음 표는 회귀 방지와 리팩터링 내성 간의 관계로 회귀 방지는 거짓 음성에서 보호하며, 리팩터링 내성은 거짓 양성의 수를 최소화한다.

| 오류 유형 표 | 오류 유형 표 | 기능                                 | 기능                             |
| ------------ | ------------ | ------------------------------------ | -------------------------------- |
| 오류 유형 표 | 오류 유형 표 | 작동                                 | 고장                             |
| 테스트 결과  | 테스트 통과  | 올바른 추론 (참 음성)                | 2종 오류 (거짓 음성) → 회귀 방지 |
| 테스트 결과  | 테스트 실패  | 1종 오류 (거짓 양성) → 리팩터링 내성 | 올바른 추론 (참 양성)            |

- 올바른 추론 (참 음성)
  - 테스트 통과, 기본 기능 의도한 대로 동작
- 올바른 추론 (참 양성)
  - 기능이 고장나서 테스트가 실패한 경우
- 거짓 음성 (2종 오류)
  - 기능이 고장났는테 테스트가 실패하지 않은 경우
  - 이를 피하기 위해서는 회귀 방지가 도움이 된다.
- 거짓 양성 (1종 오류)
  - 기능은 올바르지만 테스트가 실패한 경우
  - 허위 경보로, 리팩터링 내성이 도움이 된다.



거짓 양성과 거짓 음성의 확률이 낮을수록 테스트가 더 정확하다. 회귀 방지, 리팩터링 내성은 테스트 스위트의 정확도를 극대화하는 것을 목표로 한다.

정확도 지표는 다음 2가지 요소로 구성된다.

- 테스트가 버그 있음을 얼마나 잘 나타내는가 (거짓 음성 (회귀 방지 영역) 제외)
- 테스트가 버그 없음을 얼마나 잘 나타내는가 (거짓 양성 (리팩터링 내성 영역) 제외)



테스트 정확도는 다음과 같이 생각할 수 있는데,

**테스트 정확도 = 신호 (발견된 버그 수) / 소음 (허위 경보 발생 수)**

다음 2가지 방법으로 테스트 정확도를 향상시킬 수 있다.

- 신호를 증가시켜서 회귀를 더 잘 찾아내는 테스트로 개선하기
- 소음을 줄여서 허위 경보를 발생시키지 않는 테스트로 개선하기

즉, 가능한 한 소음 (허위 경보)이 적은 강한 신호 (버그를 찾을 수 있음)를 생성하면 테스트가 정확해진다.

### 2-2. 거짓 양성과 거짓 음성의 중요성: 역학 관계

- 프로젝트 초기에 거짓 양성은 부정적인 영향을 미치지 않지만, 시간이 지날 수록 프로젝트에 거짓 음성이 중요한 만큼 거짓 양성도 점점 중요해진다. 
  - 리팩터링은 초기보다는 시간이 지날수록 점점 중요해진다.

## 4.3 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

### 빠른 피드백

- 테스트 속도가 빠를 수록 테스트 스위트에서 더 많은 테스트를 수행, 더 자주 실행 가능
- 빠른 테스트는 코드에 결함이 생기자마자 버그에 대해 경고하기 시작할 정도로 피드백 루프를 대폭 줄여서 버그 수정 비용을 거의 0까지 줄일 수 있다.
- 느린 테스트는 피드백을 느리게 하고 잠재적으로 버그를 뒤늦게 눈에 띄게 해서 버그 수정 비용이 증가한다. 

### 유지 보수성

유지 보수성 지표는 유지비를 평가하는데, 이 지표는 다음 2가지 주요 요소로 구성된다.

- 테스트가 얼마나 이해하기 어려운가
  - 테스트의 크기와 관련 O
  - 테스트는 코드 라인이 적을수록 더 읽기 쉽고, 필요할 때 변경하기도 쉽다.
  - 테스트를 작성할 때 절차를 생략하지 말고, 일급 시민 (first-class citizen)으로 취급해라.
- 테스트가 얼마나 실행하기 어려운가
  - 테스트가 프로세스 외부 종속성으로 작동하면 데이터베이스 서버를 재부팅하고 네트워크 연결 문제를 해결하는 등 의존성을 상시 운영하는데 시간을 들여야 한다.

## 4.4 이상적인 테스트를 찾아서

### 좋은 단위 테스트의 4대 특성

좋은 단위 테스트의 4대 특성 (회귀 방지, 리팩터링 내성, 빠른 피드백, 유지 보수성)을 곱하면 테스트의 가치가 결정된다. 즉, 어떤 특성이라도 0이 되면 전체가 0이 된다.

- 가치 추정치  = [0...1] * [0...1] * [0...1] * [0...1]

- 이 평가는 테스트의 가치 추정치를 제시하며, 테스트 스위트에 테스트를 계속 둘지 여부를 결정할 수 있다.
- 테스트 코드를 포함한 모든 코드는 책임으로, 최소한으로 필요한 가치로 임계치를 상당히 높게 설정하고 이를 충족하는 테스트만 테스트 스위트에 남겨라.

### 4-1. 이상적인 테스트를 만들 수 있는가?

- 이상적인 테스트는 좋은 단위 테스트의 4대 특성 모두에서 최대 점수를 받는 테스트이다. 즉, 각 속성마다 최솟값과 최댓값을 각각 0과 1로 했을 때 이상적인 테스트는 모두 1을 얻어야 한다.
- 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 떄문에 3가지 특성 모두 최대로 하는 것은 불가능하다. 그렇기 때문에 특성 중 어느 것도 크게 줄지 않는 방식으로 최대한 크게 해야 한다.

### 4-2. 극단적인 사례 1: 엔드 투 엔드 테스트

- 엔드 투 엔드 테스트
  - 최종 사용자의 관점에서 시스템을 살펴보는 것
  - 일반적으로 UI, 데이터베이스, 외부 애플리케이션을 포함한 모든 시스템 구성 요소를 거치게 된다.
- 많은 코드 테스트 → 회귀 방지를 훌륭히 해냄
- 거짓 양성에 면역 → 리팩터링 내성 우수
- 느린 속도 때문에 빠른 피드백을 받기 어렵다.

➡️ 회귀 오류와 거짓 양성에 대한 보호를 훌륭히 해내지만, 빠른 피드백의 지표에서 실패

### 4-3. 극단적인 사례 2: 간단한 테스트

- 매우 빠르게 실행되고 빠른 피드백 제공
- 거짓 양성 생길 가능성이 매우 낮음 → 리팩터링 내성 우수
- 기반 코드에 실수할 여지가 많지 않음 → 회귀를 나타내지 않음

➡️ 우수한 리팩터링 내성과 빠른 피드백을 제공하지만, 회귀 방지가 없다.

### 4-4. 극단적인 사례 3: 깨지기 쉬운 테스트

- 실행이 빠르고 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트
- 리팩터링을 견디지 못하고, 해당 기능이 고장 났는지 여부와 관계없이 실패한다.

➡️ 빠르게 실행, 회귀 방지를 훌륭히 해내지만, 리팩터링 내성이 거의 없다.

![asdfas001](https://user-images.githubusercontent.com/95578975/181627555-e474bb1c-b3aa-4f9f-8d20-259c23602127.jpeg)

### 4-5. 이상적인 테스트를 찾아서: 결론

![실현불가능](https://user-images.githubusercontent.com/95578975/181627850-faeb38fe-7863-45fc-8c0a-c8f477f08f10.jpeg)

- 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이고 결국 3가지 특성이 모두 완벽한 점수를 가진 이상적인 테스트를 만드는 것은 불가능하다.
- 유지 보수성은 엔드 투 엔드 테스트를 제외하고 처음 3가지 특성과 상관 관계가 없다.
  - 엔드 투 엔드 테스트는 관련된 모든 의존성을 설정해야 하므로 일반적으로 크기가 더 크다.
  - 의존성을 계속 운영하려면 추가적인 노력이 더 들게 되고, 유지비 측면에서 더 비싼 경향이 있다.

- 3가지 특성을 모두 양보할 만큼 서로 조금씩 인정하는 것이 최선이지만, 실제로는 리팩터링 내성을 포기할 수 없다. 
  - 테스트에 리팩터링 내성이 있거나 없거나 둘 중 하나이기 때문에 리팩터링 내성을 포기할 수 없는 것이다.
- 최상의 테스트는 유지 보수성과 리팩터링 내성을 최대로 갖기 때문에 항상 이 2개의 특성을 최대한 많이 갖도록 해야 한다. 
- 엔드 투 엔드 테스트만 쓰거나 테스트가 상당히 빠르지 않은 한 리팩터링 내성을 최대한 많이 갖는 것을 목표로 해야 한다.
  - 테스트가 얼마나 버그를 잘 찾아내는지 (회귀 방지)와 얼마나 빠른지 (빠른 피드백) 사이의 선택으로 절충 귀결
  - 한 특성에서 얻는 것이 많을 수록 다른 특성에서 더 잃게 된다.

<img width="589" alt="스크린샷" src="https://user-images.githubusercontent.com/95578975/181629259-00b843ea-8d69-404b-a8fb-380b8cf1b37e.png">

- 테스트 스위트를 탄탄히 만들려면 테스트의 불안정성 (거짓 양성)을 제거하는 것이 최우선 과제이다.

## 4.5 대중적인 테스트 자동화 개념 살펴보기

### 5.1 테스트 피라미드 분해

<img width="513" alt="ㅁㄴ" src="https://user-images.githubusercontent.com/95578975/181634506-0fa9a198-2d64-48a3-8b66-9efce695e2b1.png">

- 테스트 스위트에서 테스트 유형 (단위 테스트, 통합 테스트, 엔드 투 엔드 테스트) 간의 일정한 비율을 내세운다.
- 층의 너비가 넓을수록 테스트가 많아진다.
- 층의 높이는 테스트가 최종 사용자의 동작을 얼마나 유사하게 모방하는지를 나타내는 척도이다.
- 피라미드의 테스트는 빠른 피드백과 회귀 방지 사이에서 선택한다. 
  - 엔드 투 엔드 테스트는 회귀 방지에 유리하고, 단위 테스트는 빠른 피드백을 강조하며, 통합 테스트는 그 중간에 있다.
- 엔드 투 엔드 테스트는 빠른 피드백 지표에서 매우 낮은 점수를 받고, 유지 보수성이 결여되기 때문에 적어야 한다.

<img width="482" alt="ㅁㄴㅇ" src="https://user-images.githubusercontent.com/95578975/181634523-c333c8c2-1c64-42af-b7f6-becc650ec516.png">

- 예외 1 : 모든 애플리케이션이 비즈니스 규칙이나 기타 복잡도가 거의 없는 기본적인 CRUD 작업일 경우
  - 단위 테스트의 수 == 통합 테스트의 수, 엔드 투 엔드 테스트가 없는 직사각형
  - 아주 단순한 예에서는 통합 테스트가 단위 테스트보다 훨씬 많을 수도 있다.
- 예외 2 : 프로젝트 외부 의존성 하나만 연결하는 API일 경우
  - 사용자 인터페이스가 없기 때문에 엔드 투 엔드 투 테스트가 빠르게 실행되고, 단일 외부 의존성으로만 작동해서 유지비도 크지 않다.
  - 이런 경우, 엔드 투 엔드 테스트를 통합 테스트와 구별할 수 없다. 유일한 차이는 진입점 뿐.
    - 엔드 투 엔드 테스트 : 최종 사용자를 완전히 모방하도록 애플리케이션을 어딘가에 호스팅
    - 통합 테스트 : 일반적으로 동일한 프로세스에서 애플리케이션을 호스팅

### 5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택

- 블랙박스 테스트
  - 시스템의 내부 구조를 몰라도 시스템의 기능 검사 가능한 소프트웨어 테스트 방법
  - 명세, 요구사항, 즉 애플리케이션이 어떻게 해야 하는지가 아닌 무엇을 해야 하는지를 중심으로 구축

- 화이트박스 테스트
  - 블랙박스 테스트의 정반대로, 애플리케이션의 내부 작업을 검증하는 테스트 방식
  - 요구사항이나 명세가 아닌 소스코드에서 테스트가 테스트 파생

|                   | 회귀 방지 | 리팩터링 내성 |
| ----------------- | --------- | ------------- |
| 화이트박스 테스트 | 좋음      | 나쁨          |
| 블랙박스 테스트   | 나쁨      | 좋음          |



- 리팩터링 내성은 타협할 수 없기 때문에, 블랙박스 테스트를 기본으로 선택해라.
- 테스트를 작성할 때에는 블랙박스 테스트를, 테스트를 분석할 때에는 화이트박스 테스트를 사용해라.
  - 코드 커버리지 도구를 통해 어떤 코드 분기를 실행하지 않았는지 확인하고, 코드 내부 구조에 대해 전혀 모르는 것처럼 테스트해라. 이런 화이트 박스 방법과 블랙 박스 방법의 조합이 제일 효과적이다.
