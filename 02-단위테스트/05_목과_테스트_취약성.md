# 05. 목과 테스트 취약성

## 5.1 목과 스텁 구분

### 1-1. 테스트 대역 유형

- 테스트 대역이란?
  - 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어.
  - 주 용도는 테스트를 편리하게 하는 것.
  - 테스트 대상 시스템으로 실제 의존성 대신 전달되므로, 설정이나 유지보수가 어려울 수 있다.
  - 테스트 대역에는 더미, 스텁, 스파이, 목, 페이크가 있고 크게 **목과 스텁**의 두 가지 유형으로 나눌 수 있다.

- 목 (목, 스파이)
  - 외부로 나가는 상호 작용을 모방하고 검사하는데 도움이 된다. 이 때의 상호 작용은 **SUT가 상태를 변경하기 위한 의존성을 호출하는 것**에 해당.
  - ex. 이메일 발송은 SMTP 서버에 부작용을 초래하는 상호 작용. 
  - 스파이는 목과 같은 역할을 한다. 스파이는 수동으로 작성하는 반면, 목은 목 프레임워크의 도움을 받아 생성된다.
- 스텁 (스텁, 더미, 페이크)
  - 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다. 이 때의 상호 작용은 **SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것**에 해당.
  - ex. 데이터베이스에서 데이터를 검색하는 것은 내부로 들어오는 상호 작용으로, 부작용을 일으키지 않는다.
  - 더미는 널 값이나 가짜 문자열과 같이 단순하고 하드코딩된 값으로, SUT의 메서드 시그니처를 만족시키기 위해 사용하고 최종 결과를 만드는 데 영향을 주지 않는다.
  - 스텁은 더 정교하고, 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성.
  - 페이크는 대다수의 목적에 부합하는 스텁과 같은데, 아직 존재하지 않는 의존성을 대체하고자 구현한다.

### 1-2. 도구로서의 목과 테스트 대역으로서의 목

- 목은 도구로서의 목, 테스트 대역으로서의 목으로 나뉜다.
- Mock 클래스로 테스트 대역 (목)을 만들 수 있기 때문에 Mock 클래스가 도구로서의 목이고, 해당 클래스의 인스턴스인 mock은 테스트 대역으로서의 목이다.

### 1-3. 스텁으로 상호 작용을 검증하지 말라

- 목은 SUT에서 관련 의존성으로 나가는 상호 작용을 모방하고 검사하는 반면, 스텁은 내부로 들어오는 상호 작용만 모방하고 검사하지 않는다.
- SUT에서 스텁으로의 호출은 SUT가 생성하는 최종 결과가 아니고, 최종 결과를 산출하기 위한 수단일 뿐이다. 스텁은 SUT가 출력을 생성하도록 입력을 제공하는 것 뿐이므로 스텁과의 상호 작용을 검증하지 말라.
  - 테스트에서 거짓 양성을 피하고 리팩터링 내성을 향상시키는 방법은 구현 세부 사항이 아닌, 최종 결과를 검증하는 것 뿐이다.
  - 스텁으로의 상호 작용을 검증하는 것은 결과로 가는 중간 단계로, 테스트 취약성으로 이어질 수 있다.
  - 결과가 올바르다면, SUT가 최종 결과를 어떻게 생성하지는 중요하지 않다.
- 최종 결과가 아닌 사항을 검증하는 관행을 과잉 명세라고 한다. 
  - 과잉 명세는 상호 작용을 검사할 때 가장 흔하게 발생한다.

### 1-5. 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?

- 명령 조회 분리 (CQS) 원칙에 따르면, 모든 메서드가 명령 또는 조회 중 하나여야 하지만 둘 다는 안된다.
  - 명령을 대체하는 테스트 대역은 목이고, 조회를 대체하는 테스트 대역은 스텁이다.
  - 명령은 부작용 O, 어떤 값도 반환하지 않는 메서드이다.
    - ex. 부작용의 예로는 객체 상태 변경, 파일 시스템 내 파일 변경 등
  - 조회는 부작용 X, 값을 반환한다.
    - 메서드가 값을 반환하면 부작용이 없어야 한다.

## 5.2 식별할 수 있는 동작과 구현 세부 사항

### 2-1 식별할 수 있는 동작은 공개 API와 다르다

모든 제품 코드는 다음의 2차원으로 분류할 수 있다.

- 공개 API 또는 비공개 API
- 식별할 수 있는 동작 또는 구현 세부 사항

각 차원의 범주는 겹치지 않는데, 메서드는 공개 API와 비공개 API 둘 다에 속할 수 없다.

코드 또한, 내부 구현 세부 사항이거나 시스템의 식별 할 수 있는 동작이지만 둘 다는 아니다.



- 메서드를 비공개 API로 만들기
  - private, internal 키워드를 통해 쉽게 비공개로 만들 수 있다.
- 코드가 시스템의 식별할 수 있는 동작으로 만들기 (다음 요구 사항 중 하나라도 충족하면 식별할 수 있는 동작이고, 그렇지 않으면 구현 세부 사항이다.)
  - 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 부작용을 초래하거나 둘 다 하는 메서드다.
  - 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다.



- 이상적으로 시스템의 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야 한다. 이러한 시스템은 API 설계가 잘 되어 있다.
- 잘 설계된 API에서 식별할 수 있는 동작은 공개 API와 일치하는 반면, 모든 구현 세부 사항은 비공개 API 뒤에 숨어있다.

- 공개 API가 식별할 수 있는 동작의 범위를 넘어서면, 시스템은 구현 세부 사항을 유출한다.

- 클래스가 구현 세부 사항을 유출하는지 판단하려면, 단일 목표를 달성하기 위해 클래스에서 호출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출할 가능성이 많다. 이상적으로는 단일 연산으로 개별 목표를 달성해야 한다.

### 2-3 잘 설계된 API와 캡슐화

- 캡슐화는 코드를 불변성 위반으로부터 보호하는 행위로, 구현 세부 사항을 사용해 코드의 불변성을 우회할 수 있기 때문에 구현 세부 사항을 노출하면 캡슐화가 위반되는 경우가 종종 있다.
- 구현 세부 사항을 숨기고 데이터와 기능을 결합하는 것이 코드 캡슐화를 달성하기 위한 수단이다.
  - 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다.
  - 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.

|        | 식별할 수 있는 동작 | 구현 세부 사항 |
| ------ | ------------------- | -------------- |
| 공개   | 좋음                | 나쁨           |
| 비공개 | 해당 없음           | 좋음           |

